{"version":3,"file":"src_app_features_user_user-details_user-details_module_ts.js","mappings":"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AK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,2BAA2B;AAC3B,uBAAuB;AACvB;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,wDAAW;AAC/B;;AAEA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,2BAA2B;AAC3B,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,6BAA6B,wDAAW;AACxC;;AAEA;AACA;AACA;AACA;;AAEA,iEAAiE;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,2BAA2B;AAC3B,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,OAAO,EAAE,GAAG;AACxD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,OAAO,EAAE,GAAG;AAC/D;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM,uDAAU;AAChB;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C,gDAAgD,iBAAiB;AACjE,+CAA+C,YAAY;AAC3D;AACA;;;AAGA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;;AAEA,qBAAqB,wDAAW;AAChC;AACA;;AAEA,2BAA2B;AAC3B,qCAAqC;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C,+CAA+C,iBAAiB;AAChE;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,oBAAoB,wDAAW;AAC/B;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA,kCAAkC,wBAAwB,IAAI,wBAAwB;AACtF;AACA;AACA,kCAAkC,mBAAmB,KAAK,oBAAoB;AAC9E;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,0BAA0B,wDAAW;;AAErC;AACA;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA,uCAAuC;AACvC,QAAQ;AACR;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA,2BAA2B;AAC3B,qCAAqC;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;;AAEA,qDAAqD;AACrD;AACA,mBAAmB,wDAAW;AAC9B,mBAAmB,wDAAW;;AAE9B;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,4CAA4C;;AAE5C,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA,wCAAwC,OAAO,iBAAiB,OAAO;AACvE;;AAEA;AACA,sCAAsC;AACtC;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,SAAS,oEAAoB;AAC7B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,SAAS,0CAAI,oCAAoC,mDAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,SAAS,mDAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,SAAS,0CAAI,oCAAoC,mDAAG;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,SAAS,0CAAI,oCAAoC,mDAAM;AACvD;AACA;AACA;;AAEA,MAAM,wDAAW;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,SAAS,0CAAI,CAAC,mDAAM;AACpB,QAAQ,wDAAW;AACnB;AACA;AACA;;AAEA;AACA,GAAG,GAAG,mDAAG,4DAA4D,oEAAoB;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,SAAS,mDAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,SAAS,mDAAM;AACf;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,SAAS,0CAAI,CAAC,mDAAM,+BAA+B,mDAAG;AACtD;AACA;;AAEA;AACA;AACA,WAAW,wDAAW;AACtB;;AAEA;AACA,GAAG,GAAG,0EAA6B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,SAAS,0CAAI,oCAAoC,mDAAM;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG,GAAG,0EAA6B;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ,SAAS,mDAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA,SAAS,0CAAI,wCAAwC,mDAAG,6DAA6D,oEAAoB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,mDAAG;AACZ;AACA,6BAA6B;AAC7B,KAAK;AACL,GAAG;AACH;;AAEA;AACA,SAAS,mDAAG;AACZ;AACA,6CAA6C;AAC7C,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,yDAAY;AAChB;AACA,CAAC;AACD,wCAAwC;AACxC;AACA;AACA,IAAI;AACJ;AACA,8CAA8C,yDAAS;AACvD;AACA,KAAK;AACL;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,8DAAiB;AACrB;AACA,CAAC;AACD,0CAA0C;AAC1C;AACA;AACA,IAAI;AACJ;AACA,+CAA+C,yDAAS;AACxD;AACA,KAAK;AACL;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEw9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpjCt6B;AACiB;AACmD;;AAEtH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6DAAuB;AACvB;AACA,SAAS,0CAAI,CAAC,6DAAuB,mBAAmB,mDAAM;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA,2BAA2B;AAC3B,qCAAqC;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,qCAAqC;AACrC;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,0CAAI,CAAC,6DAAuB,mBAAmB,mDAAM;AAC9D;AACA;AACA;AACA;;AAEA;AACA,WAAW,wDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,yHAAyH,uCAAK;AAC9H;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA,2BAA2B;AAC3B,sCAAsC;AACtC,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B,sCAAsC;AACtC;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0CAAI,CAAC,6DAAyB,oBAAoB,mDAAM;AACjE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,SAAS,0CAAI,CAAC,6DAAyB,oBAAoB,mDAAM;AACjE;AACA;AACA;AACA,WAAW,2CAAK;AAChB;AACA;AACA;;AAEA,yBAAyB,mDAAG;AAC5B;AACA;AACA;;AAEA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAW;AACpB;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAA+D;AACnE;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,iJAAiJ;AACjJ,KAAK,OAAO,mDAAG;AACf;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,oEAAoB;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEma;;;;;;;;;;;;;;;;AChQrW;AACvD;AACP,WAAW,2EAAoB;AAC/B","sources":["./src/app/features/user/user-details/components/albums/user-albums.component.ts","./src/app/features/user/user-details/components/albums/user-albums.component.html","./src/app/features/user/user-details/components/header/user-details-header.component.ts","./src/app/features/user/user-details/components/header/user-details-header.component.html","./src/app/features/user/user-details/components/page/user-details-page.component.ts","./src/app/features/user/user-details/components/page/user-details-page.component.html","./src/app/features/user/user-details/elf-state/user-albums.repository.ts","./src/app/features/user/user-details/elf-state/user-details.repository.ts","./src/app/features/user/user-details/elf-state/user-details.service.ts","./src/app/features/user/user-details/elf-state/user-posts.repository.ts","./src/app/features/user/user-details/user-details-routing.module.ts","./src/app/features/user/user-details/user-details.module.ts","./node_modules/@ngneat/elf-entities/index.esm.js","./node_modules/@ngneat/elf-requests/index.esm.js","./node_modules/rxjs/dist/esm/internal/operators/distinctUntilKeyChanged.js"],"sourcesContent":["import { Component, ChangeDetectionStrategy, Input } from '@angular/core';\nimport { NormalizedAlbumEntity } from '../../../../../core/normalizr/types/models/normalized-album-entity';\n\n@Component({\n  selector: 'app-user-albums',\n  templateUrl: './user-albums.component.html',\n  styleUrls: ['./user-albums.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserAlbumsComponent {\n  @Input() albums: NormalizedAlbumEntity[] = [];\n\n  @Input() isLoading = true;\n\n  trackByAlbum(index: number, post: NormalizedAlbumEntity): number {\n    return post.id;\n  }\n}\n","<div class=\"card\">\n  <div class=\"card-header\">\n    Albums\n  </div>\n\n  <app-content-loading-status\n    [isEmpty]=\"!albums.length\"\n    [isLoading]=\"isLoading\"\n  ></app-content-loading-status>\n\n  <ul class=\"list-group list-group-flush\">\n    <li class=\"list-group-item text-truncate\" *ngFor=\"let album of albums; trackBy: trackByAlbum\">\n      <a [routerLink]=\"['/', 'album', album.id]\">{{album.title}}</a>\n    </li>\n  </ul>\n</div>\n","import { Component, ChangeDetectionStrategy, Input } from '@angular/core';\nimport { faSpinner } from '@fortawesome/free-solid-svg-icons';\nimport { User } from '../../../../../core/types/models/user';\n\n@Component({\n  selector: 'app-user-details-header',\n  templateUrl: './user-details-header.component.html',\n  styleUrls: ['./user-details-header.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserDetailsHeaderComponent {\n  @Input() user: User | null = null;\n\n  @Input() isLoading = true;\n\n  faSpinner = faSpinner;\n}\n","<header class=\"user-details-header\">\n  <div class=\"container pt-5 pb-5 text-white\">\n    <div class=\"text-center\" *ngIf=\"isLoading\">\n      <fa-icon [icon]=\"faSpinner\" [pulse]=\"true\" role=\"status\" data-testid=\"loading-spinner\">\n        <span class=\"sr-only\">Loading...</span>\n      </fa-icon>\n    </div>\n\n    <ng-container *ngIf=\"user\">\n      <h2 class=\"mb-3\">{{user.name}}</h2>\n      <div>\n        @{{user.username}} &#8212; {{user.email}} &#8212; {{user.website}} &#8212; {{user.company.name}} &#8212; {{user.address.city}}\n      </div>\n    </ng-container>\n  </div>\n</header>\n","import { Component, ChangeDetectionStrategy, OnInit } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { NormalizedPostEntity } from '../../../../../core/normalizr/types/models/normalized-post-entity';\nimport { UserDetailsService } from '../../elf-state/user-details.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { UserPostsRepository } from '../../elf-state/user-posts.repository';\nimport { UserAlbumsRepository } from '../../elf-state/user-albums.repository';\nimport { NormalizedAlbumEntity } from '../../../../../core/normalizr/types/models/normalized-album-entity';\nimport { UserDetailsRepository } from '../../elf-state/user-details.repository';\nimport { User } from '../../../../../core/types/models/user';\n\n@Component({\n  selector: 'app-user-details-page',\n  templateUrl: './user-details-page.component.html',\n  styleUrls: ['./user-details-page.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class UserDetailsPageComponent implements OnInit {\n  posts$: Observable<NormalizedPostEntity[]> = this.postsRepo.userPosts$;\n\n  postsPending$: Observable<boolean> = this.postsRepo.pending$;\n\n  albums$: Observable<NormalizedAlbumEntity[]> = this.albumsRepo.userAlbums$;\n\n  albumsPending$: Observable<boolean> = this.albumsRepo.pending$;\n\n  user$: Observable<User | null> = this.userRepo.user$;\n\n  userPending$: Observable<boolean> = this.userRepo.pending$;\n\n  constructor(\n    private userDetails: UserDetailsService,\n    private route: ActivatedRoute,\n    private postsRepo: UserPostsRepository,\n    private albumsRepo: UserAlbumsRepository,\n    private userRepo: UserDetailsRepository,\n  ) {}\n\n  ngOnInit(): void {\n    this.route.params.subscribe((params) => {\n      const id = Number(params['id']);\n\n      this.userDetails.getUserPosts(id).subscribe();\n      this.userDetails.getUserAlbums(id).subscribe();\n      this.userDetails.getUser(id).subscribe();\n    });\n  }\n}\n","<app-user-details-header\n  [user]=\"user$ | async\"\n  [isLoading]=\"(userPending$ | async)!\"\n></app-user-details-header>\n<div class=\"container pt-3\">\n  <div class=\"row\">\n    <app-user-albums\n      class=\"col-12 col-lg-6 mb-3\"\n      [albums]=\"(albums$ | async)!\"\n      [isLoading]=\"(albumsPending$ | async)!\"\n    ></app-user-albums>\n    <app-post-list\n      class=\"col-12 col-lg-6 mb-3\"\n      [posts]=\"(posts$ | async)!\"\n      [isLoading]=\"(postsPending$ | async)!\"\n    ></app-post-list>\n  </div>\n</div>\n","import { createStore } from '@ngneat/elf';\nimport { withEntities, selectAllEntities, setEntities } from '@ngneat/elf-entities';\nimport {\n  selectIsRequestPending,\n  updateRequestStatus,\n  withRequestsStatus,\n} from '@ngneat/elf-requests';\nimport { NormalizedAlbumEntity } from '../../../../core/normalizr/types/models/normalized-album-entity';\nimport { Injectable } from '@angular/core';\n\nexport const store = createStore(\n  { name: 'userAlbums' },\n  withEntities<NormalizedAlbumEntity>(),\n  withRequestsStatus<'user-albums'>(),\n);\n\n@Injectable({ providedIn: 'root' })\nexport class UserAlbumsRepository {\n  userAlbums$ = store.pipe(selectAllEntities());\n\n  pending$ = store.pipe(selectIsRequestPending('user-albums'));\n\n  setUserAlbums(albums: NormalizedAlbumEntity[]) {\n    store.update(setEntities(albums));\n  }\n\n  setIsLoading(val: boolean): void {\n    store.update(updateRequestStatus('user-albums', val ? 'pending' : 'idle'));\n  }\n}\n","import { createStore, select, withProps } from '@ngneat/elf';\nimport { Injectable } from '@angular/core';\nimport {\n  selectIsRequestPending,\n  updateRequestStatus,\n  withRequestsStatus,\n} from '@ngneat/elf-requests';\nimport { User } from '../../../../core/types/models/user';\nimport { Observable } from 'rxjs';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UserDetailsProps {\n  user: User | null;\n}\n\nexport const store = createStore(\n  { name: 'userDetails' },\n  withProps<UserDetailsProps>({\n    user: null,\n  }),\n  withRequestsStatus<'user-details'>(),\n);\n\n@Injectable({ providedIn: 'root' })\nexport class UserDetailsRepository {\n  user$: Observable<User | null> = store.pipe(select((state) => state.user));\n\n  pending$ = store.pipe(selectIsRequestPending('user-details'));\n\n  updateUser(user: User): void {\n    store.update((state) => ({\n      ...state,\n      user,\n    }));\n  }\n\n  setIsLoading(val: boolean): void {\n    store.update(updateRequestStatus('user-details', val ? 'pending' : 'idle'));\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { UserPostsRepository } from './user-posts.repository';\nimport { ApiService } from '../../../../core/services/api.service';\nimport { NormalizedPostEntity } from '../../../../core/normalizr/types/models/normalized-post-entity';\nimport { catchError, map, Observable, tap } from 'rxjs';\nimport { NormalizedAlbumEntity } from '../../../../core/normalizr/types/models/normalized-album-entity';\nimport { UserAlbumsRepository } from './user-albums.repository';\nimport { User } from '../../../../core/types/models/user';\nimport { UserDetailsRepository } from './user-details.repository';\n\n@Injectable({ providedIn: 'root' })\nexport class UserDetailsService {\n  constructor(\n    private apiService: ApiService,\n    private postsRepo: UserPostsRepository,\n    private albumsRepo: UserAlbumsRepository,\n    private userRepo: UserDetailsRepository,\n  ) {}\n\n  getUserPosts(userId: number): Observable<NormalizedPostEntity[]> {\n    this.postsRepo.setIsLoading(true);\n    return this.apiService\n      .getPosts({\n        filter: [\n          {\n            field: 'userId',\n            value: '' + userId,\n          },\n        ],\n      })\n      .pipe(\n        map((res) => res.items),\n        tap((posts) => {\n          this.postsRepo.setIsLoading(false);\n          this.postsRepo.setUserPosts(posts);\n        }),\n        catchError((err) => {\n          this.postsRepo.setIsLoading(false);\n          throw err;\n        }),\n      );\n  }\n\n  getUserAlbums(userId: number): Observable<NormalizedAlbumEntity[]> {\n    this.albumsRepo.setIsLoading(true);\n    return this.apiService\n      .getAlbums({\n        filter: [\n          {\n            field: 'userId',\n            value: '' + userId,\n          },\n        ],\n      })\n      .pipe(\n        map((res) => res.items),\n        tap((albums) => {\n          this.albumsRepo.setIsLoading(false);\n          this.albumsRepo.setUserAlbums(albums);\n        }),\n        catchError((err) => {\n          this.albumsRepo.setIsLoading(false);\n          throw err;\n        }),\n      );\n  }\n\n  getUser(userId: number): Observable<User> {\n    this.userRepo.setIsLoading(true);\n    return this.apiService.getUser(userId).pipe(\n      tap((user) => {\n        this.userRepo.setIsLoading(false);\n        this.userRepo.updateUser(user);\n      }),\n      catchError((err) => {\n        this.userRepo.setIsLoading(false);\n        throw err;\n      }),\n    );\n  }\n}\n","import { createStore } from '@ngneat/elf';\nimport { withEntities, selectAllEntities, setEntities } from '@ngneat/elf-entities';\nimport {\n  selectIsRequestPending,\n  updateRequestStatus,\n  withRequestsStatus,\n} from '@ngneat/elf-requests';\nimport { Injectable } from '@angular/core';\nimport { NormalizedPostEntity } from '../../../../core/normalizr/types/models/normalized-post-entity';\n\nexport const store = createStore(\n  { name: 'userPosts' },\n  withEntities<NormalizedPostEntity>(),\n  withRequestsStatus<'user-posts'>(),\n);\n\n@Injectable({ providedIn: 'root' })\nexport class UserPostsRepository {\n  userPosts$ = store.pipe(selectAllEntities());\n\n  pending$ = store.pipe(selectIsRequestPending('user-posts'));\n\n  setUserPosts(posts: NormalizedPostEntity[]) {\n    store.update(setEntities(posts));\n  }\n\n  setIsLoading(val: boolean): void {\n    store.update(updateRequestStatus('user-posts', val ? 'pending' : 'idle'));\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { UserDetailsPageComponent } from './components/page/user-details-page.component';\n\nconst routes: Routes = [{ path: '', component: UserDetailsPageComponent }];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class UserDetailsRoutingModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { UserDetailsRoutingModule } from './user-details-routing.module';\nimport { UserDetailsPageComponent } from './components/page/user-details-page.component';\nimport { UserDetailsHeaderComponent } from './components/header/user-details-header.component';\nimport { UserAlbumsComponent } from './components/albums/user-albums.component';\nimport { SharedModule } from '../../../shared/shared.module';\n\n@NgModule({\n  declarations: [UserDetailsPageComponent, UserDetailsHeaderComponent, UserAlbumsComponent],\n  imports: [CommonModule, UserDetailsRoutingModule, SharedModule],\n})\nexport class UserDetailsModule {}\n","import { isFunction, capitalize, coerceArray, isDev, select, isUndefined, distinctUntilArrayItemChanged, propsFactory, propsArrayFactory } from '@ngneat/elf';\nimport { pipe } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap } from 'rxjs/operators';\n\nfunction buildEntities(entities, idKey) {\n  const asObject = {};\n  const ids = [];\n\n  for (const entity of entities) {\n    const id = entity[idKey];\n    ids.push(id);\n    asObject[id] = entity;\n  }\n\n  return {\n    ids,\n    asObject\n  };\n}\nfunction findIdsByPredicate(state, ref, predicate) {\n  const {\n    idsKey,\n    entitiesKey\n  } = ref;\n  const entities = state[entitiesKey];\n  return state[idsKey].filter(id => predicate(entities[id]));\n}\nfunction findEntityByPredicate(state, ref, predicate) {\n  const {\n    idsKey,\n    entitiesKey\n  } = ref;\n  const entities = state[entitiesKey];\n  const id = state[idsKey].find(id => {\n    return predicate(entities[id]);\n  });\n  return entities[id];\n}\nfunction checkPluck(entity, pluck) {\n  if (entity && pluck) {\n    return isFunction(pluck) ? pluck(entity) : entity[pluck];\n  } else {\n    return entity;\n  }\n}\n\nfunction getIdKey(context, ref) {\n  return context.config[ref.idKeyRef];\n}\nclass EntitiesRef {\n  constructor(config) {\n    this.idKeyRef = 'idKey';\n    this.entitiesKey = config.entitiesKey;\n    this.idsKey = config.idsKey;\n    this.idKeyRef = config.idKeyRef;\n  }\n\n}\nfunction entitiesPropsFactory(feature) {\n  const idKeyRef = feature ? `idKey${capitalize(feature)}` : 'idKey';\n  const ref = new EntitiesRef({\n    entitiesKey: feature ? `${feature}Entities` : 'entities',\n    idsKey: feature ? `${feature}Ids` : 'ids',\n    idKeyRef: idKeyRef\n  });\n\n  function propsFactory(config) {\n    let entities = {};\n    let ids = [];\n    const idKey = (config == null ? void 0 : config.idKey) || 'id';\n\n    if (config != null && config.initialValue) {\n      ({\n        ids,\n        asObject: entities\n      } = buildEntities(config.initialValue, idKey));\n    }\n\n    return {\n      props: {\n        [ref.entitiesKey]: entities,\n        [ref.idsKey]: ids\n      },\n      config: {\n        [idKeyRef]: idKey\n      }\n    };\n  }\n\n  return {\n    [`${feature}EntitiesRef`]: ref,\n    [`with${capitalize(feature)}Entities`]: propsFactory\n  };\n}\nconst {\n  withEntities,\n  EntitiesRef: defaultEntitiesRef\n} = entitiesPropsFactory('');\nconst {\n  UIEntitiesRef,\n  withUIEntities\n} = entitiesPropsFactory('UI');\n\n/**\r\n *\r\n * Remove entities\r\n *\r\n * @example\r\n *\r\n * store.update(deleteEntities(1))\r\n *\r\n * store.update(deleteEntities([1, 2, 3])\r\n *\r\n */\n\nfunction deleteEntities(ids, options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        idsKey,\n        entitiesKey\n      } = defaultEntitiesRef\n    } = options;\n    const idsToRemove = coerceArray(ids);\n    const newEntities = Object.assign({}, state[entitiesKey]);\n    const newIds = state[idsKey].filter(id => !idsToRemove.includes(id));\n\n    for (const id of idsToRemove) {\n      Reflect.deleteProperty(newEntities, id);\n    }\n\n    return Object.assign({}, state, {\n      [entitiesKey]: newEntities,\n      [idsKey]: newIds\n    });\n  };\n}\n/**\r\n *\r\n * Remove entities by predicate\r\n *\r\n * @example\r\n *\r\n * store.update(deleteEntitiesByPredicate(entity => entity.count === 0))\r\n *\r\n */\n\nfunction deleteEntitiesByPredicate(predicate, options = {}) {\n  return function reducer(state, context) {\n    const ids = findIdsByPredicate(state, options.ref || defaultEntitiesRef, predicate);\n\n    if (ids.length) {\n      return deleteEntities(ids, options)(state, context);\n    }\n\n    return state;\n  };\n}\n/**\r\n *\r\n * Remove all entities\r\n *\r\n * @example\r\n *\r\n * store.update(deleteAllEntities())\r\n *\r\n */\n\nfunction deleteAllEntities(options = {}) {\n  return function reducer(state) {\n    const {\n      ref: {\n        idsKey,\n        entitiesKey\n      } = defaultEntitiesRef\n    } = options;\n    return Object.assign({}, state, {\n      [entitiesKey]: {},\n      [idsKey]: []\n    });\n  };\n}\n\n/**\r\n *\r\n * Add entities\r\n *\r\n * @example\r\n *\r\n * store.update(addEntities(entity))\r\n *\r\n * store.update(addEntities([entity, entity]))\r\n *\r\n * store.update(addEntities([entity, entity]), { prepend: true })\r\n *\r\n */\n\nfunction addEntities(entities, options = {}) {\n  return function (state, context) {\n    const {\n      prepend = false,\n      ref = defaultEntitiesRef\n    } = options;\n    const {\n      entitiesKey,\n      idsKey\n    } = ref;\n    const idKey = getIdKey(context, ref);\n    const asArray = coerceArray(entities);\n    if (!asArray.length) return state;\n\n    if (isDev()) {\n      throwIfEntityExists(asArray, idKey, state, entitiesKey);\n      throwIfDuplicateIdKey(asArray, idKey);\n    }\n\n    const {\n      ids,\n      asObject\n    } = buildEntities(asArray, idKey);\n    return Object.assign({}, state, {\n      [entitiesKey]: Object.assign({}, state[entitiesKey], asObject),\n      [idsKey]: prepend ? [...ids, ...state[idsKey]] : [...state[idsKey], ...ids]\n    });\n  };\n}\n/**\r\n *\r\n * Add entities using fifo\r\n *\r\n * @example\r\n *\r\n *\r\n * store.update(addEntitiesFifo([entity, entity]), { limit: 3 })\r\n *\r\n */\n\nfunction addEntitiesFifo(entities, options) {\n  return function (state, context) {\n    const {\n      ref = defaultEntitiesRef,\n      limit\n    } = options;\n    const {\n      entitiesKey,\n      idsKey\n    } = ref;\n    const currentIds = state[idsKey];\n    let normalizedEntities = coerceArray(entities);\n    let newState = state;\n\n    if (normalizedEntities.length > limit) {\n      // Remove new entities that pass the limit\n      normalizedEntities = normalizedEntities.slice(normalizedEntities.length - limit);\n    }\n\n    const total = currentIds.length + normalizedEntities.length; // Remove exiting entities that passes the limit\n\n    if (total > limit) {\n      const idsRemove = currentIds.slice(0, total - limit);\n      newState = deleteEntities(idsRemove)(state, context);\n    }\n\n    const {\n      ids,\n      asObject\n    } = buildEntities(normalizedEntities, getIdKey(context, ref));\n    return Object.assign({}, state, {\n      [entitiesKey]: Object.assign({}, newState[entitiesKey], asObject),\n      [idsKey]: [...newState[idsKey], ...ids]\n    });\n  };\n}\n\nfunction throwIfEntityExists(entities, idKey, state, entitiesKey) {\n  entities.forEach(entity => {\n    const id = entity[idKey];\n\n    if (state[entitiesKey][id]) {\n      throw Error(`Entity already exists. ${idKey} ${id}`);\n    }\n  });\n}\n\nfunction throwIfDuplicateIdKey(entities, idKey) {\n  const check = new Set();\n  entities.forEach(entity => {\n    const id = entity[idKey];\n\n    if (check.has(id)) {\n      throw Error(`Duplicate entity id provided. ${idKey} ${id}`);\n    }\n\n    check.add(id);\n  });\n}\n\n/**\r\n *\r\n * Set entities\r\n *\r\n * @example\r\n *\r\n * store.update(setEntities([entity, entity]))\r\n *\r\n */\n\nfunction setEntities(entities, options = {}) {\n  return function (state, context) {\n    const {\n      ref = defaultEntitiesRef\n    } = options;\n    const {\n      entitiesKey,\n      idsKey\n    } = ref;\n    const {\n      ids,\n      asObject\n    } = buildEntities(entities, getIdKey(context, ref));\n    return Object.assign({}, state, {\n      [entitiesKey]: asObject,\n      [idsKey]: ids\n    });\n  };\n}\nfunction setEntitiesMap(entities, options = {}) {\n  return setEntities(Object.values(entities), options);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\n/**\r\n *\r\n * Get the entities collection\r\n *\r\n * @example\r\n *\r\n * store.query(getAllEntities())\r\n *\r\n */\n\nfunction getAllEntities(options = {}) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef\n  } = options;\n  return function (state) {\n    return state[idsKey].map(id => state[entitiesKey][id]);\n  };\n}\n/**\r\n *\r\n * Get the entities and apply filter/map\r\n *\r\n * @example\r\n *\r\n * store.query(getAllEntitiesApply())\r\n *\r\n */\n\nfunction getAllEntitiesApply(options) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef,\n    filterEntity = () => true,\n    mapEntity = e => e\n  } = options;\n  return function (state) {\n    const result = [];\n\n    for (const id of state[idsKey]) {\n      const entity = state[entitiesKey][id];\n\n      if (filterEntity(entity)) {\n        result.push(mapEntity(entity));\n      }\n    }\n\n    return result;\n  };\n}\n/**\r\n *\r\n * Get an entity\r\n *\r\n * @example\r\n *\r\n * store.query(getEntity(1))\r\n *\r\n */\n\nfunction getEntity$1(id, options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        entitiesKey\n      } = defaultEntitiesRef\n    } = options;\n    return state[entitiesKey][id];\n  };\n}\n/**\r\n *\r\n * Check whether the entity exist\r\n *\r\n * @example\r\n *\r\n * store.query(hasEntity(1))\r\n *\r\n */\n\nfunction hasEntity(id, options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        entitiesKey\n      } = defaultEntitiesRef\n    } = options;\n    return Reflect.has(state[entitiesKey], id);\n  };\n}\n/**\r\n *\r\n * Get the entities ids\r\n *\r\n * @example\r\n *\r\n * store.query(getEntitiesIds())\r\n *\r\n */\n\nfunction getEntitiesIds(options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        idsKey\n      } = defaultEntitiesRef\n    } = options;\n    return state[idsKey];\n  };\n}\n\nconst _excluded = [\"updater\", \"creator\"];\n\nfunction toModel(updater, entity) {\n  if (isFunction(updater)) {\n    return updater(entity);\n  }\n\n  return Object.assign({}, entity, updater);\n}\n/**\r\n *\r\n * Update entities\r\n *\r\n * @example\r\n *\r\n * store.update(updateEntities(id, { name }))\r\n * store.update(updateEntities(id, entity => ({ ...entity, name })))\r\n * store.update(updateEntities([id, id, id], { open: true }))\r\n *\r\n */\n\n\nfunction updateEntities(ids, updater, options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        entitiesKey\n      } = defaultEntitiesRef\n    } = options;\n    const updatedEntities = {};\n\n    for (const id of coerceArray(ids)) {\n      updatedEntities[id] = toModel(updater, state[entitiesKey][id]);\n    }\n\n    return Object.assign({}, state, {\n      [entitiesKey]: Object.assign({}, state[entitiesKey], updatedEntities)\n    });\n  };\n}\n/**\r\n *\r\n * Update entities by predicate\r\n *\r\n * @example\r\n *\r\n * store.update(updateEntitiesByPredicate(entity => entity.count === 0))\r\n *\r\n */\n\nfunction updateEntitiesByPredicate(predicate, updater, options = {}) {\n  return function (state, context) {\n    const ids = findIdsByPredicate(state, options.ref || defaultEntitiesRef, predicate);\n\n    if (ids.length) {\n      return updateEntities(ids, updater, options)(state, context);\n    }\n\n    return state;\n  };\n}\n/**\r\n *\r\n * Update all entities\r\n *\r\n * @example\r\n *\r\n * store.update(updateAllEntities({ name }))\r\n * store.update(updateAllEntities(entity => ({ ...entity, name })))\r\n *\r\n */\n\nfunction updateAllEntities(updater, options = {}) {\n  return function (state, context) {\n    const {\n      ref: {\n        idsKey\n      } = defaultEntitiesRef\n    } = options;\n    return updateEntities(state[idsKey], updater, options)(state, context);\n  };\n}\n/**\r\n *\r\n * Update entities that exists, add those who don't\r\n *\r\n * @example\r\n *\r\n */\n\nfunction upsertEntitiesById(ids, _ref) {\n  let {\n    updater,\n    creator\n  } = _ref,\n      options = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return function (state, context) {\n    const updatedEntitiesIds = [];\n    const newEntities = [];\n    const asArray = coerceArray(ids);\n    if (!asArray.length) return state;\n\n    for (const id of asArray) {\n      if (hasEntity(id, options)(state)) {\n        updatedEntitiesIds.push(id);\n      } else {\n        let newEntity = creator(id);\n\n        if (options.mergeUpdaterWithCreator) {\n          newEntity = toModel(updater, newEntity);\n        }\n\n        newEntities.push(newEntity);\n      }\n    }\n\n    const newState = updateEntities(updatedEntitiesIds, updater, options)(state, context);\n    return addEntities(newEntities, options)(newState, context);\n  };\n}\n/**\r\n *\r\n * Merge entities that exists, add those who don't\r\n * Make sure all entities have an id\r\n *\r\n * @example\r\n *\r\n * // single entity\r\n * store.update(upsertEntities({ id: 1, completed: true }))\r\n *\r\n * // or multiple entities\r\n * store.update(upsertEntities([{ id: 1, completed: true }, { id: 2, completed: true }]))\r\n *\r\n * // or using a custom ref\r\n * store.update(upsertEntities([{ id: 1, open: true }], { ref: UIEntitiesRef }))\r\n *\r\n */\n\nfunction upsertEntities(entities, options = {}) {\n  return function (state, context) {\n    const {\n      prepend = false,\n      ref = defaultEntitiesRef\n    } = options;\n    const {\n      entitiesKey,\n      idsKey\n    } = ref;\n    const idKey = getIdKey(context, ref);\n    const asObject = {};\n    const ids = [];\n    const entitiesArray = coerceArray(entities);\n\n    if (!entitiesArray.length) {\n      return state;\n    }\n\n    for (const entity of entitiesArray) {\n      const id = entity[idKey]; // if entity exists, merge update, else add\n\n      if (hasEntity(id, options)(state)) {\n        asObject[id] = Object.assign({}, state[entitiesKey][id], entity);\n      } else {\n        ids.push(id);\n        asObject[id] = entity;\n      }\n    }\n\n    const updatedIds = !ids.length ? {} : {\n      [idsKey]: prepend ? [...ids, ...state[idsKey]] : [...state[idsKey], ...ids]\n    };\n    return Object.assign({}, state, updatedIds, {\n      [entitiesKey]: Object.assign({}, state[entitiesKey], asObject)\n    });\n  };\n}\n/**\r\n * Update entities ids\r\n *\r\n * @example\r\n *\r\n * // Update a single entity id\r\n * store.update(updateEntitiesIds(1, 2));\r\n *\r\n * // Update multiple entities ids\r\n * store.update(updateEntitiesIds([1, 2], [10, 20]));\r\n *\r\n * // Update entity id using a custom ref\r\n * store.update(updateEntitiesIds(1, 2, { ref: UIEntitiesRef }));\r\n *\r\n */\n\nfunction updateEntitiesIds(oldId, newId, options = {}) {\n  return function (state, context) {\n    const oldIds = coerceArray(oldId);\n    const newIds = coerceArray(newId);\n\n    if (oldIds.length !== newIds.length) {\n      throw new Error('The number of old and new ids must be equal');\n    }\n\n    const {\n      ref = defaultEntitiesRef\n    } = options;\n    const idProp = getIdKey(context, ref);\n    const updatedEntities = Object.assign({}, state[ref.entitiesKey]);\n\n    for (let i = 0; i < oldIds.length; i++) {\n      const oldVal = oldIds[i];\n      const newVal = newIds[i];\n\n      if (state[ref.entitiesKey][newVal]) {\n        throw new Error(`Updating id \"${oldVal}\". The new id \"${newVal}\" already exists`);\n      }\n\n      const oldEntity = state[ref.entitiesKey][oldVal];\n      const updated = Object.assign({}, oldEntity, {\n        [idProp]: newVal\n      });\n      updatedEntities[newVal] = updated;\n      Reflect.deleteProperty(updatedEntities, oldVal);\n    }\n\n    const updatedStateIds = state[ref.idsKey].slice();\n    let processedIds = 0;\n\n    for (let i = 0; i < updatedStateIds.length; i++) {\n      const currentId = updatedStateIds[i];\n\n      for (let j = 0; j < oldIds.length; j++) {\n        const oldVal = oldIds[j];\n        const newVal = newIds[j];\n\n        if (currentId === oldVal) {\n          updatedStateIds[i] = newVal;\n          processedIds++;\n          break;\n        }\n      }\n\n      if (processedIds === oldIds.length) {\n        break;\n      }\n    }\n\n    return Object.assign({}, state, {\n      [ref.entitiesKey]: updatedEntities,\n      [ref.idsKey]: updatedStateIds\n    });\n  };\n}\n\nfunction untilEntitiesChanges(key) {\n  return distinctUntilChanged((prev, current) => {\n    return prev[key] === current[key];\n  });\n}\n/**\r\n *\r\n * Observe entities\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectAllEntities())\r\n *\r\n * store.pipe(selectAllEntities({ ref: UIEntitiesRef }))\r\n *\r\n */\n\nfunction selectAllEntities(options = {}) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef\n  } = options;\n  return pipe(untilEntitiesChanges(entitiesKey), map(state => state[idsKey].map(id => state[entitiesKey][id])));\n}\n/**\r\n *\r\n * Observe entities object\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectEntities())\r\n *\r\n * store.pipe(selectEntities({ ref: UIEntitiesRef }))\r\n *\r\n */\n\nfunction selectEntities(options = {}) {\n  const {\n    ref: {\n      entitiesKey\n    } = defaultEntitiesRef\n  } = options;\n  return select(state => state[entitiesKey]);\n}\n/**\r\n *\r\n * Observe entities and apply filter/map\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectAllEntitiesApply({\r\n *   map: (entity) => new Todo(entity),\r\n *   filter: entity => entity.completed\r\n * }))\r\n *\r\n *\r\n */\n\nfunction selectAllEntitiesApply(options) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef,\n    filterEntity = () => true,\n    mapEntity = e => e\n  } = options;\n  return pipe(untilEntitiesChanges(entitiesKey), map(state => {\n    const result = [];\n\n    for (const id of state[idsKey]) {\n      const entity = state[entitiesKey][id];\n\n      if (filterEntity(entity)) {\n        result.push(mapEntity(entity));\n      }\n    }\n\n    return result;\n  }));\n}\n\nfunction selectEntity(id, options = {}) {\n  const {\n    ref: {\n      entitiesKey\n    } = defaultEntitiesRef,\n    pluck\n  } = options;\n  return pipe(untilEntitiesChanges(entitiesKey), select(state => getEntity(state[entitiesKey], id, pluck)));\n}\nfunction getEntity(entities, id, pluck) {\n  const entity = entities[id];\n\n  if (isUndefined(entity)) {\n    return undefined;\n  }\n\n  if (!pluck) {\n    return entity;\n  }\n\n  return checkPluck(entity, pluck);\n}\nfunction selectEntityByPredicate(predicate, options) {\n  const {\n    ref = defaultEntitiesRef,\n    pluck,\n    idKey = 'id'\n  } = options || {};\n  const {\n    entitiesKey\n  } = ref;\n  let id;\n  return pipe(select(state => {\n    if (isUndefined(id)) {\n      const entity = findEntityByPredicate(state, ref, predicate);\n      id = entity && entity[idKey];\n    }\n\n    return state[entitiesKey][id];\n  }), map(entity => entity ? checkPluck(entity, pluck) : undefined), distinctUntilChanged());\n}\n\n/**\r\n *\r\n * Observe the first entity\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectFirst())\r\n *\r\n */\n\nfunction selectFirst(options = {}) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef\n  } = options;\n  return select(state => state[entitiesKey][state[idsKey][0]]);\n}\n\n/**\r\n *\r\n * Observe the last entity\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectLast())\r\n *\r\n */\n\nfunction selectLast(options = {}) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef\n  } = options;\n  return select(state => state[entitiesKey][state[idsKey][state[idsKey].length - 1]]);\n}\n\nfunction selectMany(ids, options = {}) {\n  const {\n    ref: {\n      entitiesKey\n    } = defaultEntitiesRef,\n    pluck\n  } = options;\n  return pipe(select(state => state[entitiesKey]), map(entities => {\n    if (!ids.length) return [];\n    const filtered = [];\n\n    for (const id of ids) {\n      const entity = getEntity(entities, id, pluck);\n      if (!isUndefined(entity)) filtered.push(entity);\n    }\n\n    return filtered;\n  }), distinctUntilArrayItemChanged());\n}\nfunction selectManyByPredicate(predicate, options) {\n  const {\n    ref: {\n      entitiesKey,\n      idsKey\n    } = defaultEntitiesRef,\n    pluck\n  } = options || {};\n  return pipe(untilEntitiesChanges(entitiesKey), select(state => {\n    const filteredEntities = [];\n    state[idsKey].forEach((id, index) => {\n      const entity = state[entitiesKey][id];\n\n      if (predicate(entity, index)) {\n        filteredEntities.push(checkPluck(entity, pluck));\n      }\n    });\n    return filteredEntities;\n  }), distinctUntilArrayItemChanged());\n}\n\n/**\r\n *\r\n * Observe the entities collection size\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectEntitiesCount())\r\n *\r\n */\n\nfunction selectEntitiesCount(options = {}) {\n  const {\n    ref: {\n      idsKey\n    } = defaultEntitiesRef\n  } = options;\n  return select(state => state[idsKey].length);\n}\n/**\r\n *\r\n * Observe the entities collection size  that pass the predicate\r\n *\r\n * @example\r\n *\r\n * store.pipe(selectEntitiesCountByPredicate(entity => entity.completed))\r\n *\r\n */\n\nfunction selectEntitiesCountByPredicate(predicate, options = {}) {\n  const ref = options.ref || defaultEntitiesRef;\n  return pipe(untilEntitiesChanges(ref.entitiesKey), map(state => findIdsByPredicate(state, ref, predicate).length), distinctUntilChanged());\n}\n/**\r\n *\r\n * Return the entities collection size\r\n *\r\n * @example\r\n *\r\n * store.query(getEntitiesCount())\r\n *\r\n */\n\nfunction getEntitiesCount(options = {}) {\n  return function (state) {\n    const {\n      ref: {\n        idsKey\n      } = defaultEntitiesRef\n    } = options;\n    return state[idsKey].length;\n  };\n}\n/**\r\n *\r\n * Return the entities collection size that pass the predicate\r\n *\r\n * @example\r\n *\r\n * store.query(getEntitiesCountByPredicate(entity => entity.completed))\r\n *\r\n */\n\nfunction getEntitiesCountByPredicate(predicate, options = {}) {\n  return function (state) {\n    const ref = options.ref || defaultEntitiesRef;\n    return findIdsByPredicate(state, ref, predicate).length;\n  };\n}\n\nfunction unionEntities(idKey = 'id') {\n  return map(state => {\n    return state.entities.map(entity => {\n      return Object.assign({}, entity, state.UIEntities[entity[idKey]]);\n    });\n  });\n}\n\nfunction unionEntitiesAsMap(idKey = 'id') {\n  return map(state => {\n    return Object.fromEntries(state.entities.map(entity => {\n      return [entity[idKey], Object.assign({}, entity, state.UIEntities[entity[idKey]])];\n    }));\n  });\n}\n\nconst {\n  selectActiveId,\n  setActiveId,\n  withActiveId,\n  resetActiveId,\n  getActiveId\n} = propsFactory('activeId', {\n  initialValue: undefined\n});\nfunction selectActiveEntity(options = {}) {\n  const {\n    ref = defaultEntitiesRef\n  } = options;\n  return function (source) {\n    return source.pipe(selectActiveId()).pipe(switchMap(id => source.pipe(selectEntity(id, {\n      ref\n    }))));\n  };\n}\nfunction getActiveEntity(options = {}) {\n  const {\n    ref: {\n      entitiesKey\n    } = defaultEntitiesRef\n  } = options;\n  return function (state) {\n    return state[entitiesKey][getActiveId(state)];\n  };\n}\nconst {\n  setActiveIds,\n  resetActiveIds,\n  withActiveIds,\n  selectActiveIds,\n  toggleActiveIds,\n  removeActiveIds,\n  addActiveIds,\n  getActiveIds\n} = propsArrayFactory('activeIds', {\n  initialValue: []\n});\nfunction selectActiveEntities(options = {}) {\n  const {\n    ref = defaultEntitiesRef\n  } = options;\n  return function (source) {\n    return source.pipe(selectActiveIds()).pipe(switchMap(ids => source.pipe(selectMany(ids, {\n      ref\n    }))));\n  };\n}\nfunction getActiveEntities(options = {}) {\n  const {\n    ref: {\n      entitiesKey\n    } = defaultEntitiesRef\n  } = options;\n  return function (state) {\n    const result = [];\n\n    for (const id of getActiveIds(state)) {\n      const entity = state[entitiesKey][id];\n\n      if (entity) {\n        result.push(entity);\n      }\n    }\n\n    return result;\n  };\n}\n\nexport { EntitiesRef, UIEntitiesRef, addActiveIds, addEntities, addEntitiesFifo, deleteAllEntities, deleteEntities, deleteEntitiesByPredicate, entitiesPropsFactory, getActiveEntities, getActiveEntity, getActiveId, getActiveIds, getAllEntities, getAllEntitiesApply, getEntitiesCount, getEntitiesCountByPredicate, getEntitiesIds, getEntity$1 as getEntity, hasEntity, removeActiveIds, resetActiveId, resetActiveIds, selectActiveEntities, selectActiveEntity, selectActiveId, selectActiveIds, selectAllEntities, selectAllEntitiesApply, selectEntities, selectEntitiesCount, selectEntitiesCountByPredicate, selectEntity, selectEntityByPredicate, selectFirst, selectLast, selectMany, selectManyByPredicate, setActiveId, setActiveIds, setEntities, setEntitiesMap, toggleActiveIds, unionEntities, unionEntitiesAsMap, updateAllEntities, updateEntities, updateEntitiesByPredicate, updateEntitiesIds, upsertEntities, upsertEntitiesById, withActiveId, withActiveIds, withEntities, withUIEntities };\n","import { select, coerceArray } from '@ngneat/elf';\nimport { distinctUntilKeyChanged, pipe, EMPTY, defer } from 'rxjs';\nimport { distinctUntilKeyChanged as distinctUntilKeyChanged$1, tap, map, distinctUntilChanged } from 'rxjs/operators';\n\nfunction withRequestsCache(initialValue) {\n  return {\n    props: {\n      requestsCache: initialValue != null ? initialValue : {}\n    },\n    config: undefined\n  };\n}\ndistinctUntilKeyChanged('');\nfunction selectRequestCache(key) {\n  return pipe(distinctUntilKeyChanged('requestsCache'), select(state => getRequestCache(key)(state)));\n}\nfunction updateRequestsCache(requestsOrKeys, value) {\n  let normalized = requestsOrKeys;\n\n  if (value) {\n    normalized = requestsOrKeys.reduce((acc, key) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsCache: Object.assign({}, state.requestsCache, normalized)\n    });\n  };\n}\nfunction updateRequestCache(key, {\n  ttl,\n  value: v\n} = {}) {\n  const data = {\n    value: v != null ? v : 'full'\n  };\n\n  if (ttl) {\n    data.timestamp = Date.now() + ttl;\n  }\n\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsCache: Object.assign({}, state.requestsCache, {\n        [key]: data\n      })\n    });\n  };\n}\nfunction getRequestCache(key) {\n  return function (state) {\n    var _state$requestsCache$;\n\n    const cacheValue = (_state$requestsCache$ = state.requestsCache[key]) != null ? _state$requestsCache$ : {\n      value: 'none'\n    };\n\n    if (cacheValue.timestamp && cacheValue.timestamp < Date.now()) {\n      return {\n        value: 'none'\n      };\n    }\n\n    return cacheValue;\n  };\n}\nfunction selectIsRequestCached(key, options) {\n  return pipe(distinctUntilKeyChanged('requestsCache'), select(state => isRequestCached(key, options)(state)));\n}\nfunction isRequestCached(key, options) {\n  return function (state) {\n    var _options$value;\n\n    const type = (_options$value = options == null ? void 0 : options.value) != null ? _options$value : 'full';\n    return coerceArray(key).some(k => getRequestCache(k)(state).value === type);\n  };\n}\nfunction skipWhileCached(store, key, options) {\n  return function (source) {\n    if (store.query(isRequestCached(key, {\n      value: options == null ? void 0 : options.value\n    }))) {\n      var _options$returnSource;\n\n      return (_options$returnSource = options == null ? void 0 : options.returnSource) != null ? _options$returnSource : EMPTY;\n    }\n\n    return source;\n  };\n}\nfunction createRequestsCacheOperator(store) {\n  return function (key, options) {\n    return skipWhileCached(store, key, options);\n  };\n}\nfunction clearRequestsCache() {\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsCache: {}\n    });\n  };\n}\n\nfunction withRequestsStatus(initialValue) {\n  return {\n    props: {\n      requestsStatus: initialValue != null ? initialValue : {}\n    },\n    config: undefined\n  };\n}\nfunction updateRequestsStatus(requestsOrKeys, value, error) {\n  let normalized = requestsOrKeys;\n\n  if (value) {\n    normalized = requestsOrKeys.reduce((acc, key) => {\n      acc[key] = resolveStatus(value, error);\n      return acc;\n    }, {});\n  }\n\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsStatus: Object.assign({}, state.requestsStatus, normalized)\n    });\n  };\n}\n\nfunction resolveStatus(value, error) {\n  const newStatus = {\n    value\n  };\n\n  if (value === 'error') {\n    newStatus.error = error;\n  }\n\n  return newStatus;\n}\n\nfunction updateRequestStatus(key, value, error) {\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsStatus: Object.assign({}, state.requestsStatus, {\n        [key]: resolveStatus(value, error)\n      })\n    });\n  };\n}\nfunction getRequestStatus(key) {\n  return function (state) {\n    var _state$requestsStatus;\n\n    return (_state$requestsStatus = state.requestsStatus[key]) != null ? _state$requestsStatus : {\n      value: 'idle'\n    };\n  };\n}\nfunction selectRequestStatus(key, options) {\n  return pipe(distinctUntilKeyChanged$1('requestsStatus'), select(state => {\n    const base = getRequestStatus(key)(state);\n\n    if (options != null && options.groupKey) {\n      const parent = getRequestStatus(options.groupKey)(state);\n      return parent.value === 'success' ? parent : base;\n    }\n\n    return base;\n  }));\n}\nfunction selectIsRequestPending(key) {\n  return pipe(distinctUntilKeyChanged$1('requestsStatus'), select(state => getRequestStatus(key)(state).value === 'pending'));\n}\nfunction trackRequestStatus(store, key, options) {\n  return function (source) {\n    return defer(() => {\n      if (store.query(getRequestStatus(key)).value !== 'pending') {\n        store.update(updateRequestStatus(key, 'pending'));\n      }\n\n      return source.pipe(tap({\n        error(error) {\n          store.update(updateRequestStatus(key, 'error', options != null && options.mapError ? options == null ? void 0 : options.mapError(error) : error));\n        }\n\n      }));\n    });\n  };\n}\nfunction createRequestsStatusOperator(store) {\n  return function (key, options) {\n    return trackRequestStatus(store, key, options);\n  };\n}\nfunction initializeAsPending(keys) {\n  return coerceArray(keys).reduce((acc, key) => {\n    acc[key] = {\n      value: 'pending'\n    };\n    return acc;\n  }, {});\n}\nfunction clearRequestsStatus() {\n  return function (state) {\n    return Object.assign({}, state, {\n      requestsStatus: {}\n    });\n  };\n}\n\nfunction createRequestDataSource(params) {\n  const {\n    data$,\n    store,\n    dataKey,\n    requestStatusOptions,\n    requestKey,\n    idleAsPending = false\n  } = Reflect.has(params, 'requestKey') ? params : Object.assign({}, params, {\n    requestKey: undefined\n  });\n  return {\n    trackRequestStatus: options => trackRequestStatus(store, requestKey != null ? requestKey : options == null ? void 0 : options.key, options),\n    skipWhileCached: options => skipWhileCached(store, requestKey != null ? requestKey : options == null ? void 0 : options.key, options),\n\n    setSuccess(options) {\n      return updateRequestStatus(requestKey != null ? requestKey : options == null ? void 0 : options.key, 'success');\n    },\n\n    setCached(options) {\n      return updateRequestCache(requestKey != null ? requestKey : options == null ? void 0 : options.key, options);\n    },\n\n    data$: options => store.combine({\n      data: data$(requestKey != null ? requestKey : options == null ? void 0 : options.key),\n      status: store.pipe(selectRequestStatus(requestKey != null ? requestKey : options == null ? void 0 : options.key, requestStatusOptions || {}))\n    }).pipe(map(({\n      data,\n      status\n    }) => {\n      return {\n        [dataKey]: data,\n        loading: idleAsPending ? status.value === 'pending' || status.value === 'idle' : status.value === 'pending',\n        error: status.value === 'error' ? status.error : undefined\n      };\n    }), distinctUntilChanged((a, b) => {\n      // if the status is the same, for example, `pending` and `pending`, and the `data` is the same\n      // don't emit a redundant value\n      return a[dataKey] === b[dataKey] && a.loading === b.loading && a.error === b.error;\n    }))\n  };\n}\n\nexport { clearRequestsCache, clearRequestsStatus, createRequestDataSource, createRequestsCacheOperator, createRequestsStatusOperator, getRequestCache, getRequestStatus, initializeAsPending, isRequestCached, selectIsRequestCached, selectIsRequestPending, selectRequestCache, selectRequestStatus, updateRequestCache, updateRequestStatus, updateRequestsCache, updateRequestsStatus, withRequestsCache, withRequestsStatus };\n","import { distinctUntilChanged } from './distinctUntilChanged';\nexport function distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged((x, y) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n"],"names":["UserDetailsPageComponent","constructor","userDetails","route","postsRepo","albumsRepo","userRepo","userPosts$","pending$","userAlbums$","user$","ngOnInit","params","subscribe","id","Number","getUserPosts","getUserAlbums","getUser","i0","selectors","decls","vars","consts","template"],"sourceRoot":"webpack:///"}