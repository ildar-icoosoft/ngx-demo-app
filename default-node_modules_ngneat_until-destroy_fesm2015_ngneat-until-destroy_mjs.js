"use strict";
(self["webpackChunkngx_demo_app"] = self["webpackChunkngx_demo_app"] || []).push([["default-node_modules_ngneat_until-destroy_fesm2015_ngneat-until-destroy_mjs"],{

/***/ 1082:
/*!******************************************************************************!*\
  !*** ./node_modules/@ngneat/until-destroy/fesm2015/ngneat-until-destroy.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UntilDestroy": () => (/* binding */ UntilDestroy),
/* harmony export */   "untilDestroyed": () => (/* binding */ untilDestroyed)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 228);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 6078);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 9346);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ 591);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ 9672);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 1353);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ 8728);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 3158);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ 8951);




const NG_PIPE_DEF = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵNG_PIPE_DEF"];
function isPipe(target) {
    return !!target[NG_PIPE_DEF];
}

/**
 * Applied to instances and stores `Subject` instance when
 * no custom destroy method is provided.
 */
const DESTROY = Symbol('__destroy');
/**
 * Applied to definitions and informs that class is decorated
 */
const DECORATOR_APPLIED = Symbol('__decoratorApplied');
/**
 * If we use the `untilDestroyed` operator multiple times inside the single
 * instance providing different `destroyMethodName`, then all streams will
 * subscribe to the single subject. If any method is invoked, the subject will
 * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
 * thus we store subjects under different symbols.
 */
function getSymbol(destroyMethodName) {
    if (typeof destroyMethodName === 'string') {
        return Symbol(`__destroy__${destroyMethodName}`);
    }
    else {
        return DESTROY;
    }
}
function markAsDecorated(type) {
    // Store this property on the prototype if it's an injectable class, component or directive.
    // We will be able to handle class extension this way.
    type.prototype[DECORATOR_APPLIED] = true;
}
function createSubjectOnTheInstance(instance, symbol) {
    if (!instance[symbol]) {
        instance[symbol] = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
    }
}
function completeSubjectOnTheInstance(instance, symbol) {
    if (instance[symbol]) {
        instance[symbol].next();
        instance[symbol].complete();
        // We also have to re-assign this property thus in the future
        // we will be able to create new subject on the same instance.
        instance[symbol] = null;
    }
}

function unsubscribe(property) {
    if (property instanceof rxjs__WEBPACK_IMPORTED_MODULE_2__.Subscription) {
        property.unsubscribe();
    }
}
function unsubscribeIfPropertyIsArrayLike(property) {
    Array.isArray(property) && property.forEach(unsubscribe);
}
function decorateNgOnDestroy(ngOnDestroy, options) {
    return function () {
        var _a;
        // Invoke the original `ngOnDestroy` if it exists
        ngOnDestroy && ngOnDestroy.call(this);
        // It's important to use `this` instead of caching instance
        // that may lead to memory leaks
        completeSubjectOnTheInstance(this, getSymbol());
        // Check if subscriptions are pushed to some array
        if (options.arrayName) {
            unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);
        }
        // Loop through the properties and find subscriptions
        if (options.checkProperties) {
            for (const property in this) {
                if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {
                    continue;
                }
                unsubscribe(this[property]);
            }
        }
    };
}
function decorateProviderDirectiveOrComponent(type, options) {
    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
}
function decoratePipe(type, options) {
    const def = type.ɵpipe;
    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
}
function UntilDestroy(options = {}) {
    return (type) => {
        if (isPipe(type)) {
            decoratePipe(type, options);
        }
        else {
            decorateProviderDirectiveOrComponent(type, options);
        }
        markAsDecorated(type);
    };
}

// `LView` is an array where each index matches the specific data structure.
// The 7th element in an `LView` is an array of cleanup listeners. They are
// invoked when the view is removed (similar to `ComponentRef.onDestroy`).
const CLEANUP = 7;
const CheckerHasBeenSet = Symbol('CheckerHasBeenSet');
function setupSubjectUnsubscribedChecker(instance, destroy$) {
    // This function is used within the `untilDestroyed` operator and setups a function that
    // listens for the view removal and checks if the `destroy$` subject has any observers (usually `takeUntil`).
    // Note: this code will not be shipped into production since it's guarded with `ngDevMode`,
    // this means it'll exist only in development mode.
    if (instance[CheckerHasBeenSet]) {
        return;
    }
    runOutsideAngular(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.from)(Promise.resolve())
        .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(() => {
        const lContext = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵgetLContext"])(instance);
        const lView = lContext === null || lContext === void 0 ? void 0 : lContext.lView;
        if (lView == null) {
            return rxjs__WEBPACK_IMPORTED_MODULE_5__.EMPTY;
        }
        const lCleanup = lView[CLEANUP] || (lView[CLEANUP] = []);
        const cleanupHasBeenExecuted$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
        // Note: this function is named for debugging purposes.
        lCleanup.push(function untilDestroyedLCleanup() {
            // We leave the Angular zone, so RxJS will also call subsequent `next` functions
            // outside of the Angular zone, which is done to avoid scheduling a microtask (through
            // `asapScheduler`) within the Angular zone.
            runOutsideAngular(() => cleanupHasBeenExecuted$.next());
            cleanupHasBeenExecuted$.complete();
        });
        return cleanupHasBeenExecuted$;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.observeOn)(rxjs__WEBPACK_IMPORTED_MODULE_7__.asapScheduler), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.catchError)(() => rxjs__WEBPACK_IMPORTED_MODULE_5__.EMPTY))
        .subscribe(() => {
        var _a;
        // Note: The `observed` property is available only in RxJS@7.2.0, which will throw
        // an error in lower versions. We have integration test with RxJS@6 to ensure we don't
        // import operators from `rxjs`; that's why it's wrapped into braces. The `observers`
        // property is also being deprecated.
        const observed = (_a = destroy$['observed']) !== null && _a !== void 0 ? _a : destroy$['observers'].length > 0;
        if (observed) {
            console.warn(createMessage(instance));
        }
    }));
    instance[CheckerHasBeenSet] = true;
}
function runOutsideAngular(fn) {
    var _a;
    // We cannot inject the `NgZone` class when running the checker. The `__ngContext__` is read
    // for the first time within a microtask which triggers change detection; we want to avoid that.
    // The `Zone` is always available globally when the `zone.js` is imported. Otherwise, it may be
    // nooped through bootstrap options. The `NgZone.runOutsideAngular` calls `Zone.root.run`, so we're
    // safe calling that function directly.
    const Zone = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵglobal"].Zone;
    const isNgZoneEnabled = !!Zone && typeof ((_a = Zone.root) === null || _a === void 0 ? void 0 : _a.run) === 'function';
    return isNgZoneEnabled ? Zone.root.run(fn) : fn();
}
function createMessage(instance) {
    return `
  The ${instance.constructor.name} still has subscriptions that haven't been unsubscribed.
  This may happen if the class extends another class decorated with @UntilDestroy().
  The child class implements its own ngOnDestroy() method but doesn't call super.ngOnDestroy().
  Let's look at the following example:
  @UntilDestroy()
  @Directive()
  export abstract class BaseDirective {}
  @Component({ template: '' })
  export class ConcreteComponent extends BaseDirective implements OnDestroy {
    constructor() {
      super();
      someObservable$.pipe(untilDestroyed(this)).subscribe();
    }
    ngOnDestroy(): void {
      // Some logic here...
    }
  }
  The BaseDirective.ngOnDestroy() will not be called since Angular will call ngOnDestroy()
  on the ConcreteComponent, but not on the BaseDirective.
  One of the solutions is to declare an empty ngOnDestroy method on the BaseDirective:
  @UntilDestroy()
  @Directive()
  export abstract class BaseDirective {
    ngOnDestroy(): void {}
  }
  @Component({ template: '' })
  export class ConcreteComponent extends BaseDirective implements OnDestroy {
    constructor() {
      super();
      someObservable$.pipe(untilDestroyed(this)).subscribe();
    }
    ngOnDestroy(): void {
      // Some logic here...
      super.ngOnDestroy();
    }
  }
  `;
}

function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (ngDevMode && typeof originalDestroy !== 'function') {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        // eslint-disable-next-line prefer-rest-params
        originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            ngDevMode && ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        const destroy$ = instance[symbol];
        ngDevMode && setupSubjectUnsubscribedChecker(instance, destroy$);
        return source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.takeUntil)(destroy$));
    };
}
function ensureClassIsDecorated(instance) {
    const prototype = Object.getPrototypeOf(instance);
    const missingDecorator = !(DECORATOR_APPLIED in prototype);
    if (missingDecorator) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-node_modules_ngneat_until-destroy_fesm2015_ngneat-until-destroy_mjs.js.map